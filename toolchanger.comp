component toolchanger               	"This component controls the Boxford 240 Lathe Auto Tool Changer. M6 calls this";

pin in bit toolchange               	"Receives signal from M6 that tool change required";
pin in s32 toolnumber               	"Receives Tx data from M6 (tool number requested) Only allows 1-8";
pin in s32 currenttoolnumber        	"Receives old tool number";
pin in float stepgen_pos_fb				"Position-feedback from stepgen";
pin in bit atc_limit	    			"ATC limit switch";
pin out float position_cmd          	"Sends location required";
pin out float velocity_cmd          	"Sends location required";


pin out bit toolchanged =false      	"Sends signal when tool change finished";
pin in bit enable = false          		"Toolchanger enable signal";

pin in bit jog_forward = false       	"Facilitate jogging of stepgen via component";
pin in bit jog_back = false          	"Facilitate jogging of stepgen via component";
pin in float jog_move = 0            	"distance to jog";

pin in bit axis_homing;
pin in bit axis_homed;

option singleton yes;               	
function _;
license "GPL";
;;

#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <unistd.h>

#define HOMING_DELAY 1;

static bool homing = false; 
static bool homed = false;
static bool delay = false;
static float timer;

enum events {
	RESET,
    PREPARE_HOMED,
    PREPARE_SLEEP,
    HOMING_START,
    HOMING_SEARCH,
    HOMING_LATCH,
    HOMING_FINISH,
    CHANGE_TOOL,
    CHANGE_ADVANCE,
    CHANGE_LOCK,
    DEFAULT
};

enum states {
	PREPARE,
	HOMING,
	CHANGE
};

enum events event;
enum states state;

FUNCTION(_)
{	
    if( axis_homing ) event = RESET;

    switch(state) {
        case PREPARE:
            if( axis_homed ) event = PREPARE_HOMED;
            if( delay ) event = PREPARE_SLEEP;
        break;
        case HOMING:
            if( !homed ) {

            }
        break;
        case CHANGE:

        break;
        default:
        break;
    }

    switch(event) {
        case RESET:
            // reset
            homed = false;
            state = PREPARE;
            break;
        case PREPARE_HOMED:
            // machine is homed, register time and dispatch sleep event
            if (delay == false) {
                timer = HOMING_DELAY;
                delay = true;
            }
            break;
        case PREPARE_SLEEP:
            timer -= fperiod;
            if (timer <= 0){
                timer = 0;
                delay = false;
                state = HOMING;
                event = HOMING_START;
            }
            break;
        case HOMING_START:
            position_cmd = 10;
            if (stepgen_pos_fb > (10 - 0.1)) {
                event = HOMING_SEARCH;
                rtapi_print_msg(RTAPI_MSG_ERR, "HOMING_SEARCH");
            }
            break;
        case HOMING_SEARCH:
            if (!atc_limit) {
                position_cmd = 360 + 40;
            } else {
                position_cmd = stepgen_pos_fb + 1;
                event = HOMING_LATCH;    
                rtapi_print_msg(RTAPI_MSG_ERR, "HOMING_LATCH");
            }
            break;
        case HOMING_LATCH:
            if (atc_limit) {
                position_cmd = stepgen_pos_fb + 50;
            } else {
                position_cmd = stepgen_pos_fb - 22;
                event = HOMING_FINISH;
                rtapi_print_msg(RTAPI_MSG_ERR, "HOMING_FINISH");
            }
            break;
        case HOMING_FINISH:
            rtapi_print_msg(RTAPI_MSG_ERR, "Homed");
            homed = true;
            event = DEFAULT;
            break;
        case CHANGE_TOOL:
            break;
        case CHANGE_ADVANCE:
            break;
        case CHANGE_LOCK:
            break;
        default:
            break;
    }
}
