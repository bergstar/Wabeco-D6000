component toolchanger "This component controls the Boxford 240 Lathe Auto Tool ";

pin in bit enable = false "Toolchanger enable signal";

pin in bit tool_change "Receives signal from M6 that tool change required";
pin out bit tool_changed "Sends signal when tool change finished";
pin in s32 tool_requested "Receives Tx data from M6 (tool number requested) Only allows 1-8";
pin in s32 tool_current "Receives old tool number";
pin out s32 tool_physical = 0; // Reflects current locked tool in ATC
pin out s32 tool_target = 0; // Reflects requested tool number

pin out s32 tool_locking = false; // Indicates that tool is about to get locked
pin out s32 tool_locked = false; 

pin out s32 atc_active = false; 
pin in bit atc_limit "ATC limit switch";

pin in float position_fb "Position-feedback from stepgen";
pin out float position_cmd "Sends location required";
variable float position_req = 0; // Where we want to be

pin out bit homed = false "Sends signal when ATC has finished homing";
pin out bit homing = false "Sends signal when ATC is currently homing";

pin in bit axis_homing;
pin in bit axis_homed;

option singleton yes;

function _;
license "GPL";
;;

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>

#define HOMING_DELAY 1;
#define LOCKING_DELAY 1;

#define TOOL_MOVE 52; // tool move including moving away from the lock 
#define LATCHING_MOVE 5 // threshold on when to start the slow move
#define LOCK_MOVE 7; // move in oposit direction, locking the tool
#define LOCK_STOP 0.1; // slamming into physical stop

#define STEP_LOCKING 0.001;
#define STEP_SLOW 0.005;
#define STEP_NORMAL 0.01;
#define STEP_FAST 0.03;

static bool delay = false;
static float timer;
static int remaining(const int current, const int target);

enum events {
  RESET,
  PREPARE_HOMED,
  PREPARE_SLEEP,
  HOMING_START,
  HOMING_SEARCH,
  HOMING_LATCH,
  HOMING_FINISH,
  CHANGE_CONTROL,
  CHANGE_PROGRESS,
  CHANGE_TOOL,
  CHANGE_ADVANCE,
  CHANGE_LOCK,
  CHANGE_COMPLETE,
  DEFAULT
};

enum events event;

FUNCTION(_) {

  if ( axis_homing ) event = RESET;

  if ( tool_change && homed && !atc_active ) {      
    event = CHANGE_CONTROL;
  }

  switch (event) {

  case RESET:

    // reset
    homed = false;
    tool_changed = 0;
    atc_active = false;

    if (axis_homed) event = PREPARE_HOMED;

    break;

  case PREPARE_HOMED:

    // machine is homed, register time and dispatch sleep event
    if (delay == false) {
      delay = true;
      timer = HOMING_DELAY;

      event = PREPARE_SLEEP;
    }

    break;

  case PREPARE_SLEEP:

    timer -= fperiod;

    if (timer <= 0) {
      timer = 0;
      delay = false;

      event = HOMING_START;
    }

    break;

  case HOMING_START:

    // check if limit switch is tripped
    // if it is, release it by moving away
    if (atc_limit) {
      position_cmd = 25;
    } else {
      event = HOMING_SEARCH;
    }

    break;

  case HOMING_SEARCH:

    if (!atc_limit) {
      position_cmd = 360 + 50;
    } else {
      position_cmd = position_fb + LATCHING_MOVE;

      event = HOMING_LATCH;
    }

    break;

  case HOMING_LATCH:

    if (atc_limit) {
      position_cmd += 1;
    } else {    
      position_cmd = position_fb - 23;
      if (delay == false) {
        timer = LOCKING_DELAY;
        delay = true;
      }
      event = HOMING_FINISH;
    }

    break;

  case HOMING_FINISH:

    timer -= fperiod;

    if (timer <= 0) {
      timer = 0;

      delay = false;

      homed = true;
      
      tool_locked = true;

      tool_physical = 2;

      event = DEFAULT;
    }
    break;

  case CHANGE_CONTROL:
  
    tool_changed = 0;
    atc_active = true;

    if ( tool_physical == tool_requested ) {
      // current tool is the tool requested, do nothing. 
      tool_changed = 1;
      atc_active = false;
  
      event = DEFAULT;
    } else {
      tool_target = tool_requested;
      // lets do some tool changes 
      event = CHANGE_PROGRESS;
    }

    break;

  case CHANGE_PROGRESS:

    if ( tool_physical == tool_target ) {
      // current tool is the tool requested
      tool_changed = 1;
      atc_active = false;
  
      tool_target = 0;
      event = DEFAULT;
    } else {
      if ( remaining(tool_physical, tool_requested) == 1 ) {
        tool_locking = true;
      } else {
        tool_locking = false;
      }
      // add check for lock move
      event = CHANGE_TOOL;
    }

    break;

  case CHANGE_TOOL:

    position_req = position_fb + TOOL_MOVE;      

    // we need to move less since tool is not locked
    if ( tool_locked == false ) position_req = position_req - LOCK_MOVE;   

    event = CHANGE_ADVANCE;

    break;

  case CHANGE_ADVANCE:

      
    if ( position_fb < position_req ) {
      if ( position_fb < position_req - LATCHING_MOVE ) {
        position_cmd += STEP_FAST;
      } else {
        position_cmd += STEP_NORMAL;
      }      
    }

    if ( tool_locking == true ) {
      if ( position_fb >= position_req ) {
        position_req = position_fb - LOCK_MOVE - LOCK_STOP;
        event = CHANGE_LOCK;
      }
    } else {
      // moved tool without locking it
      tool_locked = false;

      event = CHANGE_COMPLETE;
    }

    break;

  case CHANGE_LOCK:

    if ( position_fb > position_req ) {
      if ( ( position_req - position_fb ) < LATCHING_MOVE ) {
        position_cmd -= STEP_SLOW;
      } else {
        position_cmd -= STEP_LOCKING;
      }   
    }

    if ( position_fb <= position_req ) {
      // moved tool and locked it
      tool_locked = true;

      event = CHANGE_COMPLETE;
    }

    break;

  case CHANGE_COMPLETE:
    // tool change complete, advance tool counter
    tool_physical += 1;

    if ( tool_physical > 8 ) tool_physical = tool_physical - 8;

    event = CHANGE_PROGRESS;
    
    break;

  default:
    tool_changed = 0;

    break;
  }
}

/* function descripgion */
int remaining(const int current, const int target) {
  int result;

  result = 8 - current + target;

  if ( result > 8 ) result = result - 8;
 
  return result; 
}